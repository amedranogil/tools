/**
 * transformation Ontology UML 2 Java transformation for universAAL
 * date: 28/6/2011
 * author: Erlend Stav, StŒle Walderhaug
 * description: 
 */

texttransformation OntologyUML2Java (in uml:"http://www.eclipse.org/uml2/3.0.0/UML") {


  var ontologyNamespace:String
  var ontologyName:String
  var ontologyNamespaceReference:String


 
   /**
   * Main (entry point)
   */
    
  uml.Model::main() {
    
    if (!self.hasStereotype("owlOntology")) {
      
      StdOut.println("WARNING!!! The model must be stereotyped with owlOntology and default namespace must be set!")  
      StdOut.println("To perform the transformation, add this information to the model")
      return 
    }
    
    ontologyName = self.name 
    StdOut.println("Generating Java classes for ontology: " + ontologyName)
    ontologyNamespace = self.getStereotypeValue("owlOntology", "defaultNamespace")
    StdOut.println("Namespace: "+ontologyNamespace) 
    ontologyNamespaceReference =  ontologyName +  'Namespace.NAMESPACE'  
  
    
         
  	self.ownedMember -> forEach( p:uml.Package ){         
        var ontologyClassList:Hashtable
 
 	  	StdOut.println("Handling namespace interface of package :" + p.name) 
   		p.generateNamespaceInterface()

	  	StdOut.println("Handling classes of package :" + p.name) 
  		//Generate a java-class for each class in the ontology
		p.ownedElement -> forEach( component:uml.Class ) { // | component.hasStereotype("owlClass") ){
		    ontologyClassList.put(component.name, component)
			component.generateOntologyClass()
		}

	  	StdOut.println("Handling interfaces of package :" + p.name) 
  		//Generate a java-class for each interface in the ontology
		p.ownedElement -> forEach( inter:uml.Interface ) { // | component.hasStereotype("owlClass") ){
			inter.generateOntologyInterface()
  		    ontologyClassList.put(self.name, self)
		}

	  	StdOut.println("Handling activator of package :" + p.name) 
   		p.generateActivator(ontologyClassList)
                                         
	}           
  }
 
 
  uml.Package::generateActivator(ontologyClassList:Hashtable) {
    StdOut.println('Generating activator')
    
	file( self.name.replace("\\.", "/") + '/' + "Activator.java" )
    
'
package ' self.name ';

import org.osgi.framework.BundleActivator;
import org.osgi.framework.BundleContext;

public class Activator implements BundleActivator {

  static BundleContext context = null;

    public void start(BundleContext context) throws Exception {
      Activator.context = context;
'
	ontologyClassList.values()->forEach(component:uml.Class) {
'      Class.forName(' component.package.name '.' component.name '.class.getName());
'
	}
'    }

    public void stop(BundleContext arg0) throws Exception {
	// TODO Auto-generated method stub

    }

}	
'	

  }
  
  uml.Package::generateNamespaceInterface() {
    StdOut.println('Generating name space interface')
    
	file( self.name.replace("\\.", "/") + '/' + ontologyName + "Namespace.java" )
    
'
package ' self.name ';

import org.osgi.framework.BundleActivator;
import org.osgi.framework.BundleContext;

public interface ' ontologyName 'Namespace {

  static final String NAMESPACE = "' ontologyNamespace '#";

}	
'	

  }  
  
  
  uml.Classifier::toUpperFormat():String {
    var txt:String
    var res:String
  
    txt = self.name.trim()
    res = ""

    txt->forEach(aChar:String) {
      if (aChar.isUpperCase(0)) {
        res = res + "_";
      }
      res = res + aChar;
    }  

  	return res.toUpper()
  }   

  uml.NamedElement::getStereotypeValue(stereotypeName:String, tag:String):String {
    // Find and return the value of a stereotype    
   var mySType:uml.Stereotype
   if (self.hasStereotype(stereotypeName)) {
     mySType = self.getAppliedStereotype(stereotypeName);
     return self.getValue(mySType, tag)
   }
   else {
     StdOut.println("The class "+self.name+" do not have the expected stereotype : " + stereotypeName)
     return ""
   }
  }


	
  uml.Interface::generateOntologyInterface() {
	file( self.package.name.replace("\\.", "/") + '/' + self.name + ".java" )
                
    //Start generating the code
    'package ' self.package.name ';\n\n'
    
    self.genImports()
    
	self.genInterfaceDeclaration()
	    
    ' {\n'
    
    self.genInterfaceProperties()
    
    '}\n'    
  }



  uml.Class::generateOntologyClass () {
	file( self.package.name.replace("\\.", "/") + '/' + self.name + ".java" )
                
    //Start generating the code
    'package ' self.package.name ';\n\n'
    
    self.genImports()
  	self.genClassDeclaration()
	    
    ' {\n'
   
    self.genPropertyDeclaration()
    self.genPropertiesForAssociations()
    self.genStatic()
    self.genConstructors()
    self.genGetClassRestrictionsOnProperty()
    self.genGetStandardPropertyURIs()
    
    self.genGetPropSerializationType()
    self.genIsWellFormed()
    self.genGetRDFSComment()
    self.genGetRDFSLabel()
   
    self.genPropertyGettersAndSetters()
    
    
    '}\n'    
  }
 
  uml.Class::genImports() {
    'import java.util.Hashtable;\n\n'
    
    // Import universAAL packages. 
    // Note that generator currently imports a fixed set of classes. This will be improved in the future 
    'import org.universAAL.middleware.owl.Restriction;\n'
    'import org.universAAL.middleware.service.owl.Service;\n'    
    'import org.universAAL.ontology.phThing.Device;\n\n'
  }

  uml.Class::genStatic() {
    '  static {\n'
    '    MY_URI = ' ontologyNamespaceReference '+ "' self.name.trim() '";\n' 
    self.ownedMember->forEach(att : uml.Property) {
  	    //initializing properties
	    '    PROP_' att.toUpperFormat() ' = ' ontologyNamespaceReference ' + "' att.name.trim() '";\n'

	}
	
	self.getAssociations()->forEach (ass : uml.Association | ass.endType.first().name.trim().equals(self.name.trim()) ) {
	  '    PROP_' ass.memberEnd.last().toUpperFormat() ' = ' ontologyNamespaceReference ' + "' ass.memberEnd.last().name.trim() '";\n'
	
	}
  	'\n'
    '    register('self.name'.class);\n'
    '  }\n'
  }     
  
  uml.Interface::genInterfaceProperties() {
     '  public static final String MY_URI = ' ontologyNamespaceReference ' + "' self.name.trim() '";\n' 
    
    self.ownedMember->forEach(att : uml.Property) {
  	   if (att.type == null) {
	        stdout.println("WARNING: No type defined for " + att.name +  ". Using string as default")
	        '  public static final String PROP_' att.toUpperFormat() ' = ' ontologyNamespaceReference ' + "' att.name.trim() '";\n'
	    }
	    else {
	    	'  public static final ' att.type 'PROP_' att.toUpperFormat() ' = ' ontologyNamespaceReference ' + "' att.name.trim() '";\n'
	    	}
		
	}
    '\n'
  
  }
  
  uml.Class::genClassDeclaration() {
    'public ' if (self.isAbstract) {'abstract '} 'class ' self.name
    if (self.superClass.isEmpty()) {
      stdout.println("Warning: Class " + self.name + " has no super class")
    }
    else {  
      ' extends '
      self.superClass.first().name 
      if (self.superClass.size() > 1) {
        stdout.println("WARNING: Class " + self.name + " is defined to have multiple superclasses. Use interfaces instead - additional superclasses are igonered!")
      }        
    }
    if (!self.interfaceRealization.isEmpty()) {
      ' implements '
      var firstInter:Boolean 
      firstInter = true
      self.interfaceRealization->forEach(inter:uml.InterfaceRealization) {
        '' inter.supplier.first().name ' '
        if (!firstInter) {','}          
        firstInter = false
      }
    }
  }




  uml.Interface::genInterfaceDeclaration() {
    'public interface ' self.name
    if (!self.generalization.isEmpty()) {
      ' extends '
      var firstInter:Boolean 
      firstInter = true

      self.generalization->forEach(gen : uml.Generalization) {
        if (!firstInter) {','}          
        '' gen.general.name ' '
        firstInter = false
      }
    }
  }
  
  uml.Classifier::genPropertyDeclaration() {
  	//insert default identifier for each owlClass
  	'  public static final String MY_URI;\n'
  	self.ownedMember->forEach(att : uml.Property) {
  	   	
  	   	//iterate through each property and declare them as static
	    if (att.type == null) {
	        stdout.println("WARNING: No type defined for " + att.name  + ". Using string as default")
	    }
        '  public static final String PROP_' att.toUpperFormat() ';\n'
	}
  '\n'
  }
 
  
  uml.Class::genConstructors() {
    '
  public ' self.name ' () {
    super();
  }
  
  public ' self.name ' (String uri) {
    super(uri);
  }\n'
  }    
  
  uml.Class::genGetClassRestrictionsOnProperty() {
'
  public static Restriction getClassRestrictionsOnProperty(String propURI) {
'
    unprotect {
'
    // TODO: Restrictions are currently not supported by the transformation scripts
    // Code entered in this section will not be overwritten by the transformations if
    // the code is generated again
          
    if (propURI == null)
	    return null;

	// Typical code to include is something like:
	// if (PROP_BEAMING_DIRECTION.equals(propURI))
	//   return Restriction.getAllValuesRestrictionWithCardinality(propURI,Location.MY_URI, 1, 0);
'
      if (self.superClass.isEmpty()) {
        '    return null;\n'
      }
      else {
        '    return ' self.superClass.first().name '.getClassRestrictionsOnProperty(propURI);\n'	  	  
      }
    
    }
'  }\n\n'
  }  
  
 
   uml.Class::genGetStandardPropertyURIs() {
 	// First, check if there is any property URIs to add. If not, do not generate this method
 	
	// Generate method
'   
  public static String[] getStandardPropertyURIs() {
    //TODO: Code generation for this will be added soon...
'      
//	String[] inherited = Device.getStandardPropertyURIs();
//	String[] toReturn = new String[inherited.length + 1];
//	int i = 0;
//	while (i < inherited.length) {
//	    toReturn[i] = inherited[i];
//	    i++;
//	}
//	toReturn[i] = PROP_MEASURED_VALUE;
//	return toReturn;
'	return null;
  }\n'    
   }

  uml.Class::genPropertiesForAssociations() {
      //generate 
      self.getAssociations()->forEach(ass : uml.Association | ass.endType.first().name.trim().equals(self.name.trim())) {
      '  public static final String PROP_'  ass.memberEnd.last().toUpperFormat() ';\n'
      }
		
	}


   uml.Class::genGetPropSerializationType() {
   }

   uml.Class::genIsWellFormed() {
'
  public boolean isWellFormed() {
	return true '
	
  	self.ownedMember->forEach(att : uml.Property) {
  	    '\n      && props.containsKey(PROP_'att.toUpperFormat()')'
  	}
 	self.getAssociations()->forEach (ass : uml.Association | ass.endType.first().name.trim().equals(self.name.trim()) ) {
  	    '\n      && props.containsKey(PROP_'ass.memberEnd.last().toUpperFormat()') '
 	}  
    ';
  }\n'
       
   }  

   uml.Class::genGetRDFSComment() {
'
  public static String getRDFSComment() {
'
    if (self.ownedComment.isEmpty()) {
      self.genGetRDFSCommentDefault()
    }
    else {
     '    return "' self.ownedComment.first().body '";\n'
    } 
      
'  }'

   }
  
   uml.Class::genGetRDFSCommentDefault() {
	 unprotect{
'
    //TODO: enter a description of the class here\'
	return "Description of class 'self.name'";
'     		
 	}
   }
  
  
   uml.Class::genGetRDFSLabel() {
 '
  public static String getRDFSLabel() {
    return "'self.name.trim()'";
  }
'    
   
   }



   // Methods for generating getters and setters for properties

   uml.Class::genPropertyGettersAndSetters() {
     
   	//iterate through each property and generate getter and setter methods 
  	self.ownedMember->forEach(att : uml.Property) {
		var theTypeName:String = "String"	
		var methodName:String = att.name.trim().firstToUpper()
		var propLongName:String = "PROP_" + att.toUpperFormat()
		
		if (att.type != null) {
		  theTypeName = att.type.name
		}

		if (theTypeName == "Boolean") {
		  self.genBooleanGetterAndSetter(methodName, propLongName)
    	}  		  
		else if (theTypeName == "UnlimitedNatural") {
		  self.genLongGetterAndSetter(methodName, propLongName)
		}
   	    else if (theTypeName == "Integer") {
		  self.genIntGetterAndSetter(methodName, propLongName)
		}		
		else {
		  self.genObjectGetterAndSetter(methodName, propLongName, theTypeName)
		}	
	}
 
 	self.getAssociations()->forEach (ass : uml.Association | ass.endType.first().name.trim().equals(self.name.trim()) ) {
      var methodName:String = ass.memberEnd.last().name.trim().firstToUpper()
      var propLongName:String = "PROP_" + ass.toUpperFormat()
      var theTypeName:String = ass.endType.last().name
	  self.genObjectGetterAndSetter(methodName, propLongName, theTypeName)       	  
	}
     
   }

   uml.Class::genBooleanGetterAndSetter(methodName:String, propertyLongName:String) {
'
  public boolean is' methodName '() {
	Boolean b = (Boolean) props.get('propertyLongName');
	return (b == null) ? false : b.booleanValue();
  }		

  public void set'methodName'(boolean newPropValue) {
      props.put('propertyLongName', new Boolean(newPropValue));
  }		
'		
   }
   
   uml.Class::genIntGetterAndSetter(methodName:String, propertyLongName:String) {
'
  public int get' methodName '() {
	Integer i = (Integer) props.get('propertyLongName');
	return (i == null) ? 0 : i.intValue();
  }		

  public void set'methodName'(int newPropValue) {
      props.put('propertyLongName', new Integer(newPropValue));
  }		
'		
   }

   uml.Class::genLongGetterAndSetter(methodName:String, propertyLongName:String) {
'
  public long get' methodName '() {
	Long l = (Long) props.get('propertyLongName');
	return (l == null) ? 0 : l.longValue();
  }		

  public void set'methodName'(long newPropValue) {
      props.put('propertyLongName', new Long(newPropValue));
  }		
'		
   }

   uml.Class::genObjectGetterAndSetter(methodName:String, propertyLongName:String, typeName:String) {
'
  public 'typeName ' get' methodName '() {
    return ('typeName')props.get('propertyLongName');
  }		

  public void set'methodName'('typeName' newPropValue) {
    if (newPropValue != null)
      props.put('propertyLongName', newPropValue);
  }		
'		
   }


}

