/**
 * transformation Ontology UML 2 Java transformation for universAAL
 * date: 28/6/2011
 * author: Erlend Stav, StŒle Walderhaug
 * description: 
 */

texttransformation OntologyUML2Java (in uml:"http://www.eclipse.org/uml2/3.0.0/UML") {


  var ontologyClassList:Hashtable
  var ontologyNamespace:String


 
   /**
   * Main (entry point)
   */
    
  uml.Model::main() {
    
    if (!self.hasStereotype("owlOntology")) {
      
      StdOut.println("WARNING!!! The model must be stereotyped with owlOntology and default namespace must be set!")  
      StdOut.println("To perform the transformation, add this information to the model")
      return 
    }
    
    ontologyNamespace = self.getStereotypeValue("owlOntology", "defaultNamespace")
    StdOut.println("Namespace: "+ontologyNamespace)  
         
    'Starting the transformation\n' 
  	self.ownedMember -> forEach( p:uml.Package ){         
                                        
	  	'Handling classes of package :' p.name '\n' 
  		//Generate a java-class for each class in the ontology
		p.ownedElement -> forEach( component:uml.Class ) { // | component.hasStereotype("owlClass") ){
			component.generateOntologyClass()
		}

		'Handling interfaces\n'                
  		//Generate a java-class for each interface in the ontology
		p.ownedElement -> forEach( inter:uml.Interface ) { // | component.hasStereotype("owlClass") ){
		    'An interface\n'                
			inter.generateOntologyInterface()
		}
                                         
	}           
    'Handling activator\n'
   	self.generateActivator()
  }
 
 
  uml.Model::generateActivator() {
    'Generating activator'
	file( "Activator.java" )
//	file( self.package.name.replace("\\.", "/") + '/' + "Activator.java" )

	var pkg:Object;
	pkg = ontologyClassList.values.first()

'
package '	
	if (pkg != null) {
      pkg.package.name
	}
	else {	  	
	  'default'
	}
';

import org.osgi.framework.BundleActivator;
import org.osgi.framework.BundleContext;

public class Activator implements BundleActivator {

  static BundleContext context = null;

    public void start(BundleContext context) throws Exception {
      Activator.context = context;
'
	ontologyClassList.values()->forEach(component:uml.Class) {
'      Class.forName(' component.package.name '.' component.name '.class.getName());
'
	}
'    }

    public void stop(BundleContext arg0) throws Exception {
	// TODO Auto-generated method stub

    }

}	
'	

  }
  
  uml.Property::toUpperFormat():String {
    var txt:String
    var res:String
  
    txt = self.name
    res = ""

    txt->forEach(aChar:String) {
      if (aChar.isUpperCase(0)) {
        res = res + "_";
      }
      res = res + aChar;
    }  

  	return res.toUpper()
  }   

  uml.NamedElement::getStereotypeValue(stereotypeName:String, tag:String):String {
    // Find and return the value of a stereotype    
   var mySType:uml.Stereotype
   if (self.hasStereotype(stereotypeName)) {
     mySType = self.getAppliedStereotype(stereotypeName);
     return self.getValue(mySType, tag)
   }
   else {
     StdOut.println("The class "+self.name+" do not have the expected stereotype : " + stereotypeName)
     return ""
   }
  }


	
  uml.Interface::generateOntologyInterface() {
	file( self.package.name.replace("\\.", "/") + '/' + self.name + ".java" )
                
    //Start generating the code
    'package ' self.package.name ';\n\n'
    
    self.genImports()
    
	self.genInterfaceDeclaration()
	    
    ' {\n'
  	
  	self.genPropertyDeclaration()
    
    '}\n'    
  }



  uml.Class::generateOntologyClass () {
	ontologyClassList.put(self.name, self)
    	
	file( self.package.name.replace("\\.", "/") + '/' + self.name + ".java" )
                
    //Start generating the code
    'package ' self.package.name ';\n\n'
    
    self.genImports()
    
	self.genClassDeclaration()
	

	    
    ' {\n'
    
    
    self.genPropertyDeclaration()
    self.genStatic()
    
    self.genConstructors()
    
    self.genGetClassRestrictionsOnProperty()
    self.genGetStandardPropertyURIs();
    
    '}\n'    
  }
 
  uml.Class::genImports() {
    'import java.util.Hashtable;\n\n'
    
    //Import universAAL packages.
    'import org.universAAL.middleware.owl.Restriction;\n'
    'import org.universAAL.middleware.service.owl.Service;\n\n'    
  }

  uml.Class::genStatic() {
    '  static {\n'
    self.ownedMember->forEach(att : uml.Property) {
  	    //initializing properties
	    '    PROP_' att.toUpperFormat() '= insert_namespace_' att.name '\n'
	}
  	'\n'
    '    register('self.name'.class);\n'
    '  }\n'
  }     
  
  
  uml.Class::genClassDeclaration() {
    'public ' if (self.isAbstract) {'abstract '} 'class ' self.name
    if (self.superClass.isEmpty()) {
      stdout.println("Warning: Class " + self.name + " has no super class")
    }
    else {  
      ' extends '
      self.superClass.first().name 
      if (self.superClass.size() > 1) {
        stdout.println("WARNING: Class " + self.name + " is defined to have multiple superclasses. Use interfaces instead - additional superclasses are igonered!")
      }        
    }
    if (!self.interfaceRealization.isEmpty()) {
      ' implements '
      var firstInter:Boolean 
      firstInter = true
      self.interfaceRealization->forEach(inter:uml.InterfaceRealization) {
        '' inter.supplier.first().name ' '
        if (!firstInter) {','}          
        firstInter = false
      }
    }
  }




  uml.Interface::genInterfaceDeclaration() {
    'public interface ' self.name
    if (!self.generalization.isEmpty()) {
      ' extends '
      var firstInter:Boolean 
      firstInter = true

      self.generalization->forEach(gen : uml.Generalization) {
        if (!firstInter) {','}          
        '' gen.general.name ' '
        firstInter = false
      }
    }
  }
  
  uml.Classifier::genPropertyDeclaration() {
  	//insert default identifier for each owlClass
  	'  public static final String MY_URI;\n'
  	self.ownedMember->forEach(att : uml.Property) {
  	  	
  	   	
  	   	//iterate through each property and declare them as static
	    if (att.type == null) {
	        stdout.println("WARNING: No type defined for " + att.name  + ". Using string as default")
	        '  public static final String PROP_' att.name.toUpper() ';\n'
	    }
	    else {
	    	'  public static final PROP_' att.type ' ' att.name.toUpper() ';\n'
	    	}
				
		
	}
  '\n'
  }
 
  
  uml.Class::genConstructors() {
    '
  public ' self.name ' () {
    super();
  }
  
  public ' self.name ' (String uri) {
    super(uri);
  }\n'
  }    
  
  uml.Class::genGetClassRestrictionsOnProperty() {
'
  public static Restriction getClassRestrictionsOnProperty(String propURI) {
    if (propURI == null)
	    return null;
	if (PROP_BEAMING_DIRECTION.equals(propURI))
	    return Restriction.getAllValuesRestrictionWithCardinality(propURI,
		    Location.MY_URI, 1, 0);
	if (PROP_TARGET_SURFACE.equals(propURI))
	    return Restriction.getAllValuesRestrictionWithCardinality(propURI,
		    Location.MY_URI, 1, 0);\n'
    if (self.superClass.isEmpty()) {
      'return null;\n'
    }
    else {
      'return ' self.superClass.first().name '.getClassRestrictionsOnProperty(propURI);\n'	  	  
    }
'  }\n\n'
  }  
  
 
   uml.Class::genGetStandardPropertyURIs() {
 	// First, check if there is any property URIs to add. If not, do not generate this method
 	
	// Generate method
'   
    public static String[] getStandardPropertyURIs() {
'      
//	String[] inherited = Device.getStandardPropertyURIs();
//	String[] toReturn = new String[inherited.length + 1];
//	int i = 0;
//	while (i < inherited.length) {
//	    toReturn[i] = inherited[i];
//	    i++;
//	}
//	toReturn[i] = PROP_MEASURED_VALUE;
//	return toReturn;
'	return null;
    }\n'    
   }
  
}
