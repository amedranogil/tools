/**
 * transformation NewTransformation
 * date: 14/10/2012
 * author: null
 * description: 
 */

texttransformation ServiceModelEMF2Java (in mdl:"http://www.universaal.org/tools/modelling/serviceprofile") {

  var javaBasePath:String

  mdl.ServiceInterface::main () {
	 javaBasePath = "./"
     self.generateLevel2Interface()
  }
  
  //get the full name of the root package
  mdl.ServiceInterface::getFullOwnerPackageName():String {
  	return "org.universaal.test." + self.name
  }
  

 /*
  * This operation will handle the level 2 interface generation
  */
  mdl.ServiceInterface::generateLevel2Interface() {
  	//create the file
  	var interfaceName:String = self.name.trim()
	file( javaBasePath + "/" + self.getFullOwnerPackageName().replace("\\.", "/") + '/' + interfaceName + ".java" )
  	  
	//create the header for the level2 interface
	self.generateLevel2InterfaceHeader()
			
	//create the operations for the level2 interface
	self.generateLevel2InterfaceOperations()

	//close the interface
	'}'
}  

 /*
  * This operation will create the 
  */
  mdl.ServiceInterface::generateLevel2InterfaceHeader() {
   
    'package ' self.getFullOwnerPackageName() ';	'
	//static imports
	'\n
import org.universAAL.middleware.api.annotation.ChangeEffect;
import org.universAAL.middleware.api.annotation.Input;
import org.universAAL.middleware.api.annotation.OntologyClasses;
import org.universAAL.middleware.api.annotation.Output;
import org.universAAL.middleware.api.annotation.Outputs;
import org.universAAL.middleware.api.annotation.ServiceOperation;
import org.universAAL.middleware.api.annotation.UniversAALService;'
	
	//dynamic imports. Must import the service that is implemented as well as the classes that are used as properties
	var propertyImportHash: Hashtable
	
	//get realization class
	
	// TODO: Add something corresponding to realzation class
	//var serviceClass: uml.Class
	//serviceClass = self.clientDependency.first().supplier.first()
	
	//set the ontologyClass name
	//ontologyClass = serviceClass.name
	
	//get the name of the realizationService and format it for import
	String realizationService = serviceClass.qualifiedName.substringAfter("::").replace("::", ".")
	'\nimport ' realizationService ';'
	
	//get the serviceclass' ownedattributes' type
	
	/*
	serviceClass->forEach( prop : uml.Property) {
		propertyImportHash.put(prop.name, prop)
		//stdout.println("Found property on serviceClass: " + prop.name + ":" + prop.type)
	}
	
	//import the superclasses 	
	while (!serviceClass.general.isEmpty()) {
	  	serviceClass.ownedElement->forEach(prop: uml.Property){
	  		propertyImportHash.put(prop.name, prop)
	  		//if property is an objecttype (class), import its property types as well
	  		if (prop.type.oclIsTypeOf(uml.Class)) {
	  			prop.type.ownedElement->forEach(subProp: uml.Property) {
	  				propertyImportHash.put(subProp.name,subProp)
	  				//stdout.println("SubProperty: " + subProp.name + " inserted")
	  			}
	  		}
	  	}
	  	serviceClass = serviceClass.general.first()
	}
	
    //print the import statements
	propertyImportHash->forEach(prop : uml.Property) {
	  if (!prop.type==null) {
	    if (prop.type.oclIsTypeOf(uml.Class) || prop.type.oclIsTypeOf(uml.Enumeration)) {
	    '\nimport ' prop.type.getFullPackageName() ';'
	    }
	  }
	}
			
	//declare the service
	'\n\n@UniversAALService(namespace = ' self.name '.namespace, name="' self.name '")\n'
	'@OntologyClasses(value = {' ontologyClass '.class})\n'
	'public interface ' self.name ' {\n'
	
	//set the namespace based on the packagename reversed
	'\n\tpublic final static String namespace = "http://' reverseDelimitedString(self.getFullOwnerPackageName(), ".") '/' self.name '.owl#";'
	 */
    
}
  
mdl.ServiceProfile::generateAnnotated() {
    // self.createEffectTypeMap()
'
	@ServiceOperation
'
	var separator:String = ""

	// Print any outputs 
	if (self.output.isEmpty()) {
	
		'	@Outputs(value = { '
		separator = ""
		self.output->forEach(outParam:mdl.Parameter) {
			separator + '@Output(name = "' + outParam.name + '")'  // TODO: replace name with correct value
			separator = ", "
		}
		'})
'
	}	

	// Print any change effects

/*	self.effects->forEach(c) {
		var effectCls:uml.Class = c._getFeature("base_Class")
		var effectType:String = effectCls.getValue("ServiceEffect", "effectType").name
		'	' + effectTypeMap.get(effectType) + '(propertyPaths = { '
		
		var effectProps:List = effectCls.getValue("ServiceEffect", "effectProperties")
		var valueType:String = ""
		separator = ""
		effectProps->forEach(p:uml.Property) {
		    separator + p.owner.name + '.PROP_' p.toUpperFormat()
			separator = ", "
			valueType = p.type.name // Use type of last property
		}
		' },\n'
		'		value = "' + effectCls.getValue("ServiceEffect", "effectValue") + '",'
		' valueType = ' + valueType + '.class)\n'
					
		// TODO: find what to use for value type
	}
*/	
	 
	// Print the method signature
	'	public ' 
	// Determine return type
	if (self.output.size() == 0) {
		'void '
	} else if (self.output.size() > 1) {
	  'Object[] '
	} else {
	  var returnParam:mdl.Parameter = self.output.first()
	  var arrayAdd: String = ""
//	  if (returnParam.upperValue <> 1) {
//	    arrayAdd = '[]'
//	  }
//	  returnParam.getTypeFromParameter() + arrayAdd +  ' '
	}
	
	self.name

	'('
	separator = ""
    self.input->forEach(par:mdl.Parameter) {
   		separator + '@Input(name = "'par.name'") '+  ' void ' par.name  //par.type.name
//   		separator + '@Input(name = "'par.name'") '+ par.getTypeFromParameter() + ' ' par.name  //par.type.name
		separator = ", "
    }
	');
'	
}  
  
    /*
     * This operation will generate the annotated operations of the level 2 interface
     * It uses the information set on the operations to decide input/output/changeeffect paramters
     */
mdl.ServiceInterface::generateLevel2InterfaceOperations() {
    //call generate annotated
    self.profiles->forEach(pro : mdl.ServiceProfile){
    	pro.generateAnnotated()
    }
}


}