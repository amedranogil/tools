	/**
 * transformation Ontology UML 2 Java transformation for universAAL
 * date: 28/6/2011
 * author: Erlend Stav, StŒle Walderhaug
 * description: 
 */

texttransformation OntologyUML2JavaV2 (in uml:"http://www.eclipse.org/uml2/3.0.0/UML") {


/**
 * Change required:
 * - update POM file
 * - add new ontology class
 * -- create OntClassInfoSetup variable for each ontology class with createNewAbstractOntClassInfo / createNewOntClassInfo
 * -- in second loop, add all other info for each ontology class incl. comment, resourceLabel, superclass, then the following:
 * -- add support for properties
 * -- add support for restrictions
 * -- add support for enumerations
 * -- add suppport for imports
 */


  var ontologyNamespace:String
  var ontologyName:String
  var ontologyNamespaceReference:String
  var propertyHashtable: Hashtable  
  var projectInfo: Hashtable
  var importedModels: Hashtable
  var javaBasePath:String

 
   /**
   * Main (entry point)
   */
    
  uml.Model::main() {
    javaBasePath = getEnv("org.universaal.tools.transformationcommand.javadir")
    
    if (!self.hasStereotype("owlOntology")) {
      
      StdOut.println("WARNING!!! The model must be stereotyped with owlOntology and default namespace must be set!")  
      StdOut.println("To perform the transformation, add this information to the model")
      return 
    }
    
    ontologyName = self.name 
    StdOut.println("Generating Java classes for ontology: " + ontologyName)
    
    //ontologyNamespace = "http:\\\\\\\\ontology.universAAL.org\\\\"+ontologyName; //self.getStereotypeValue("owlOntology", "defaultNamespace")
    ontologyNamespace = self.getStereotypeValue("owlOntology", "defaultNamespace")
    StdOut.println("Namespace: "+ontologyNamespace) 
    ontologyNamespaceReference =  ontologyName +  'Ontology.NAMESPACE'  
  
    
    //must create the import list.
    self.getImportList()
         
  	self.ownedMember -> forEach( p:uml.Package ){         
        var ontologyClassList:Hashtable
        var ontologyEnumerationList:Hashtable
   		
   		//Create a hashtable containing the properties of the classes in the model.
   		StdOut.println("Handling properties of classes (not interfaces) in the package: " + p.name)
   		p.ownedElement->forEach(c : uml.Class) {
   			c.createPropertyList()
  			c.createPropertyListForAssociations()
  			
   		}
		//now see if there are any associations that own both its ends
		p.ownedElement->forEach(ass : uml.Association) {ass.createPropertyForAssociations()}

	  	StdOut.println("Handling classes of package :" + p.name) 
  		//Generate a java-class for each class in the ontology
		p.ownedElement -> forEach( component:uml.Class ) { // | component.hasStereotype("owlClass") ){
		    ontologyClassList.put(component.name, component)
			component.generateOntologyClass()
		}
   		
		p.ownedElement -> forEach( component:uml.Enumeration ) { // | component.hasStereotype("owlClass") ){
		    ontologyEnumerationList.put(component.name, component)
			component.generateEnumerationClass()
		}

	  	StdOut.println("Handling main ontology class for :" + p.name) 
   		p.generateMainOntologyClass(ontologyClassList, ontologyEnumerationList)

	  	StdOut.println("Handling factory for :" + p.name) 
   		p.generateFactory(ontologyClassList)

	  	StdOut.println("Handling activator of :" + p.name) 
   		p.generateActivator(ontologyClassList)


		StdOut.println("Generating the POM file")
		//create the POM file for the project
		p.generatePOMFile() 

                                         
	}           
  }
 
 
  uml.Package::generateActivator(ontologyClassList:Hashtable) {
	file( javaBasePath + "/" + self.name.replace("\\.", "/") + '/' + "Activator.java" )
    
'
package ' self.name ';

import org.osgi.framework.BundleActivator;
import org.osgi.framework.BundleContext;
import org.universAAL.middleware.owl.OntologyManagement;
import 'self.name'.owl.*;

public class Activator implements BundleActivator {

  static BundleContext context = null;
  'ontologyName'Ontology ontology = new 'ontologyName'Ontology();

  public void start(BundleContext context) throws Exception {
    Activator.context = context;
    OntologyManagement.getInstance().register(ontology);
  }

  public void stop(BundleContext arg0) throws Exception {
    OntologyManagement.getInstance().unregister(ontology);
  }
}	
'	

  }


  uml.Package::generateMainOntologyClass(ontologyClassList:Hashtable, enumerationClassList:Hashtable) {
	file( javaBasePath + "/" + self.name.replace("\\.", "/") + '/owl/' + ontologyName + "Ontology.java" )

'
package ' self.name '.owl;

import org.universAAL.middleware.owl.BoundingValueRestriction;
import org.universAAL.middleware.owl.DataRepOntology;
import org.universAAL.middleware.owl.ManagedIndividual;
import org.universAAL.middleware.owl.MergedRestriction;
import org.universAAL.middleware.owl.OntClassInfoSetup;
import org.universAAL.middleware.owl.Ontology;
import org.universAAL.middleware.rdf.Resource;
import org.universAAL.middleware.rdf.TypeMapper;
import org.universAAL.middleware.service.owl.Service;
import org.universAAL.middleware.service.owl.ServiceBusOntology;
import org.universAAL.ontology.location.Location;
import org.universAAL.ontology.location.LocationOntology;
import org.universAAL.ontology.phThing.Device;
import ' self.name '.' ontologyName 'Factory;


/**
 * @author AAL Studio 
 */
public final class ' ontologyName 'Ontology extends Ontology {

  private static ' ontologyName 'Factory factory = new ' ontologyName 'Factory();
  public static final String NAMESPACE ="' ontologyNamespace '#";
	
  public ' ontologyName 'Ontology() {
    super(NAMESPACE);
  }

  public void create() {
    Resource r = getInfo();
    r.setResourceComment("' self.owner.getFirstCommentText() '");
    r.setResourceLabel("'ontologyName'");
    addImport(DataRepOntology.NAMESPACE);
    addImport(ServiceBusOntology.NAMESPACE);
    addImport(LocationOntology.NAMESPACE);
		
    
'
		
		if (!enumerationClassList.isEmpty()) {
            '\n\n    // ******* Declaration of enumeration classes of the ontology ******* //\n\n'        		  
			enumerationClassList->forEach(enumClass : uml.Enumeration) {
			  '    OntClassInfoSetup oci_' enumClass.name' = createNewAbstractOntClassInfo('enumClass.name'.MY_URI);\n'
			}
		}
			  
		'\n\n    // ******* Declaration of regular classes of the ontology ******* //\n'

		//create a ontclassinfo for each ontology class in the ontologyClassList
		var index:Integer
		index = 0
		
		ontologyClassList->forEach(c: uml.Class) {	
			if (c.isAbstract) { 
				'    OntClassInfoSetup oci_' c.name.trim() ' = createNewAbstractOntClassInfo(' c.name.trim() '.MY_URI);\n'
			}
			else {
				'    OntClassInfoSetup oci_' c.name.trim() ' = createNewOntClassInfo(' c.name.trim() '.MY_URI, factory, ' index ');\n'
				index+=1
			} //end check for abstract class
		}
			
			
		if (!enumerationClassList.isEmpty()) {
		    '\n\n    // ******* Add content to enumeration classes of the ontology ******* //\n\n'        		  
			enumerationClassList->forEach(enumClass : uml.Enumeration) {
			  var oci:String = "oci_" + enumClass.name.trim()
			  '    ' oci '.setResourceComment("' enumClass.getFirstCommentText() '");\n'
			  '    ' oci '.setResourceLabel("'enumClass.name.trim() '");\n'
			  if (!enumClass.isAbstract) {
			    enumClass.generalization->forEach(gen:uml.Generalization) {
			      '    ' oci '.addSuperClass('gen.general.name'.MY_URI);\n'
			    }
			    '    ' oci '.toEnumeration(new ManagedIndividual[] {\n'
			    '      '
			    var litCount:Integer = 0
			    enumClass.ownedLiteral->forEach(lit:uml.EnumerationLiteral) {
			      if (litCount > 0) { 
			        ','
			      }
			      ' 'enumClass.name.trim()'.'lit.name.trim()
			      litCount = litCount + 1;
			      //TODO: Add linebreak if many?
			    }
			    ' });\n\n'
			    
			  }					  
			}
		}

	   '\n\n    // ******* Add content to regular classes of the ontology ******* //\n'	
		
		ontologyClassList->forEach(c: uml.Class) {		  
		  var oci:String = "oci_"  + c.name.trim()
			'    'oci '.setResourceComment("' c.getFirstCommentText() '");\n'
			'    'oci '.setResourceLabel("' c.name.trim() '");\n' 
			
			//add reference to the superclass. In case of multiple inheritance, use the first entry in set
			if (c.superClass.size()>0) {
				c.superClass->forEach(sc: uml.Class) {
					'    'oci '.addSuperClass(' sc.name '.MY_URI); \n'	
			  	}	
			}
		
			//using the class's hashtable for properties
			Hashtable props = propertyHashtable.get(c.name)
			Boolean isObjectProperty = true //true=objectproperty, false=datatypeproperty, default=true
			Boolean isFunctional = true //true/false, default=true
			//go through the attributes first
			props->forEach(prop : uml.Property) {
				//get stereotype and check for datatypeproperty. Otherwise objectproperty.
				isObjectProperty = true
				isFunctional = true
				if (prop.hasStereotype("datatypeProperty")) { //datatypeProperty
					isObjectProperty = false
					isFunctional = prop.getValue("datatypeProperty", "isFunctional")
				}
				else  if (prop.hasStereotype("objectProperty")) {
				  	isFunctional = prop.getValue("objectProperty", "isFunctional")
				}
				else {
					if (prop.isDataType()) {
						isObjectProperty = false
					}		  
				}			
				
				
				if (isObjectProperty) {
			  		if (isFunctional){ //default = true
						'    ' oci '.addObjectProperty(' c.name'.PROP_' prop.toUpperFormat() ').setFunctional();\n'
					}
					else {
						'    ' oci '.addObjectProperty(' c.name'.PROP_' prop.toUpperFormat() ');\n'
					}
				}
				else {
					if (isFunctional){ //default = true
						'    ' oci '.addDatatypeProperty(' c.name'.PROP_' prop.toUpperFormat() ').setFunctional();\n'
					}
					else {
						'    ' oci '.addDatatypeProperty(' c.name'.PROP_' prop.toUpperFormat() ');\n'
					}//isfunctional = true
				}
				
				
		
		 		 //handle 0..* cardinality
		  		if (prop.upper<0 && prop.lower==0) {
					'      	' oci '.addRestriction(MergedRestriction.getAllValuesRestriction(' c.name '.PROP_' prop.toUpperFormat() ',  \n'
					'       	' self.getURIExpressionForType(prop.type.name.trim()) '));\n'
					'	    \n'
		 		} //if 0..*
		  		else if (!prop.type.name.trim().equals("") ) {  //this is a datatype property that has been set.
						'    ' oci '.addRestriction(MergedRestriction\n'
						'      .getAllValuesRestrictionWithCardinality(' c.name '.PROP_' prop.toUpperFormat() ', \n'	  
						'      'self.getURIExpressionForType(prop.type.name.trim())', ' prop.lower ', ' prop.upper ')'
						if (prop.defaultValue.name.equals("values")) { //TODO: this is a temporary solution. See doc for more info
							//TODO: must check for property type. Now supporting Integer only
							'\n      ' prop.getBoundingRestriction(c.name)
						}
						');\n'
						'    \n'
		 		 	} //else if
		 		else {    //default when unset type
		 		  	'    ' oci '.addRestriction(MergedRestriction.getCardinalityRestriction(' c.name '.PROP_' prop.toUpperFormat() ', ' prop.lower ', ' prop.upper '));\n'
					'    \n'
		 		}
		 	} //forEach	prop
	 	
		} //forEach class
'  }
}
'
  }
		
  uml.Property::isDataType() {
	var theTypeName:String = "String"	
	
	if (self.type != null) {
		  theTypeName = self.type.name
	}

	if (theTypeName == "Boolean") {
	  return true
    }  		  
	else if (theTypeName == "UnlimitedNatural") {
	  return true
	}
    else if (theTypeName == "Integer") {
      return true
	}		
	else if (theTypeName == "String") {
	  return true
	}
	return false
    
  }


 
  uml.Package::generateFactory(ontologyClassList:Hashtable) {
	file( javaBasePath + "/" + self.name.replace("\\.", "/") + '/' + ontologyName + "Factory.java" )
    
'
package ' self.name ';

import org.osgi.framework.BundleActivator;
import org.osgi.framework.BundleContext;
import org.universAAL.middleware.rdf.Resource;
import org.universAAL.middleware.rdf.impl.ResourceFactoryImpl;
import 'self.name'.owl.*;

public class ' ontologyName 'Factory extends ResourceFactoryImpl {


  public Resource createInstance(String classURI, String instanceURI, int factoryIndex) {

	switch (factoryIndex) {
'
	var classIndex:Integer = 0
	ontologyClassList.values()->forEach(component:uml.Class) {
	  // Generate factory entry only for concrete classes
	  if (component.isAbstract == false) {
		'     case ' classIndex ':\n'
		'       return new 'component.name'(instanceURI);\n'
		classIndex = classIndex + 1
	  }
	}
'
	}
	return null;
  }
}
'
  }


  uml.Property::getBoundingRestriction(className: String):String {
    var txt:String
    var res:String
  
    //get the default value string specification. This string holds the range - min, max.
    //TODO: add support for more ranges and sets.
    txt = self.defaultValue.value.trim()
 
    res = ""
  
    //currently only integer is supported
    if (self.type.name.equals("Integer")) {
 	  res = ".addRestriction(new BoundingValueRestriction(" + className + ".PROP_" + self.toUpperFormat() 
  	  res = res + ", new Integer(" + txt.substringBefore("..") + "), true, new Integer(" + txt.substringAfter("..")+  "), true))"
    }
 
    return res //empty or a boundingrestriction.
  }
  
  
  uml.Classifier::toUpperFormat():String {
    var txt:String
    var res:String
  
    txt = self.name.trim()
    res = ""

    txt->forEach(aChar:String) {
      if (aChar.isUpperCase(0)) {
        res = res + "_";
      }
      res = res + aChar;
    }  

  	return res.toUpper()
  }   

  uml.NamedElement::getStereotypeValue(stereotypeName:String, tag:String):String {
    // Find and return the value of a stereotype    
   var mySType:uml.Stereotype
   if (self.hasStereotype(stereotypeName)) {
     mySType = self.getAppliedStereotype(stereotypeName);
     return self.getValue(mySType, tag)
   }
   else {
     StdOut.println("The class "+self.name+" do not have the expected stereotype : " + stereotypeName)
     return ""
   }
  }


  uml.NamedElement::getFirstCommentText():String {
    if (self.ownedComment.isEmpty()) {
      return ""
    }
    else {
      // Checking the body for null do not work, so instead we check that the body is of type String
      if (self.ownedComment.first().body.oclGetType().equals("String"))
        return self.ownedComment.first().body.trim()
      else
        return ""
    }    
  }  


  uml.Class::generateOntologyClass () {
	file( javaBasePath + "/" + self.package.name.replace("\\.", "/") + '/owl/' + self.name + ".java" )
                
    //Start generating the code
    'package ' self.package.name '.owl;\n\n'
    
    self.genImports()
  	self.genClassDeclaration()
	    
    ' {\n'
   
  	
    self.genPropertyDeclaration()

    self.genConstructors()
    self.genGetClassURI()
    
    self.genGetPropSerializationType()
    self.genIsWellFormed()
    
    //self.genGetClassLevelRestrictions()
   
    self.genPropertyGettersAndSetters()
   
    '}\n'    
  }

  uml.Enumeration::generateEnumerationClass () {
	file( javaBasePath + "/" + self.package.name.replace("\\.", "/") + '/owl/' + self.name + ".java" )
              
    //Start generating the code
    'package ' self.package.name '.owl;\n\n'
    
  	'import org.universAAL.middleware.owl.ManagedIndividual;\n\n'
  
  	self.genEnumClassDeclaration()
	    
    ' {\n'
   
    self.genPropertyDeclaration()

	if (self.isAbstract) {
	  self.genAbstractEnumerationContent()
	}
	else {
	  var enumCount:Integer = 0
	  self.ownedLiteral->forEach(enumLit : uml.EnumerationLiteral) {
	    '  public static final int 'enumLit.toUpperFormat()' = 'enumCount';\n'
	    enumCount = enumCount + 1	    
	  }
	  '\n'
	  
      '  private static final String[] names = {\n'
      '    '
      var firstEnum:Boolean = true
	  self.ownedLiteral->forEach(enumLit : uml.EnumerationLiteral) {
	    if (!firstEnum) {
	      	','
	    }	    
	    '"'enumLit.name.trim()'"'
	    firstEnum = false
	  }
      ' };\n\n'
      
	  self.ownedLiteral->forEach(enumLit : uml.EnumerationLiteral) {
	    '  public static final 'self.name' ' enumLit.name.trim() ' = new ' self.name '(' enumLit.toUpperFormat()');\n'
	  }	
    
      // Generate privat constructor
'
  private int order;

  private 'self.name'(int order) {
    super('ontologyName'Ontology.NAMESPACE + names[order]);
    this.order = order;
  }

  public int getPropSerializationType(String propURI) {
    return PROP_SERIALIZATION_OPTIONAL;
  }

  public boolean isWellFormed() {
    return true;
  }

  public String name() {
    return names[order];
  }

  public int ord() {
    return order;
  }
'	  
	  
      self.genGetClassURI()
      '\n'
          
      '  public static 'self.name' get'self.name'ByOrder(int order) {\n'
	  '    switch (order) {\n'
	  self.ownedLiteral->forEach(enumLit : uml.EnumerationLiteral) {
	    '      case 'enumLit.toUpperFormat()':\n'
        '        return 'enumLit.name.trim()';\n'
	  }	
	  '    default:\n'
	  '      return null;'
	  '    }\n'
	  '  }\n\n'


'  public static final 'self.name' valueOf(String name) {
	if (name == null)
	    return null;

	if (name.startsWith('ontologyName'Ontology.NAMESPACE))
	    name = name.substring('ontologyName'Ontology.NAMESPACE.length());

	for (int i = 'self.ownedLiteral.first().toUpperFormat()'; i <= 'self.ownedLiteral.last().toUpperFormat()'; i++)
	    if (names[i].equals(name))
		return get'self.name'ByOrder(i);

	return null;
  }
'    
    
    
	}
	
   
    '}\n'    
  }

  uml.Enumeration::genAbstractEnumerationContent() {
'
  protected 'self.name'(String uri) {
    super(uri);
  }
    
  public String getClassURI() {
	return MY_URI;
  }
'	    
  }  

  uml.Enumeration::genEnumClassDeclaration() {
    var superClassName:String = "ManagedIndividual"
    if (!self.generalization.isEmpty()) {
     superClassName = self.generalization.first().general.name
    }
    'public ' if (self.isAbstract) {'abstract '} 'class ' self.name ' extends ' superClassName
  }

  
  /*
   * Will get the properties for the class and put it into the propertyHashtable
   * The properties are stored as as <class.name,hashtable<property.name, property>> records
   */
  uml.Class::createPropertyList() {
 	//look if there is an entry in the hashtable for the active classifier.
 	var pHash:Hashtable = propertyHashtable.get(self.name)
 	
 	self.ownedMember->forEach(att : uml.Property) {
 		//add property to list and update the hashtable. 
 	   	pHash.put(att.name, att) //key=property.name. ELement = property
    }
 
    //update propertyHashtable
    if (!pHash.isEmpty()){
 		propertyHashtable.put(self.name,pHash) //key=class.name. Element = hashtable
    	//stdout.println("INFO: Property hashtable updated for key " + self.name + " (size=" + pHash.size() +"). Total size=" + propertyHashtable.size() )
   }
  }
  
  /**
   * This function will only deal with associations. It updates the navigable classifiers in the propertyHash
   * with information about their navigable ends   *
   */
  uml.Association::createPropertyForAssociations() {
    //get the navigable ends
  	self.navigableOwnedEnd->forEach(p : uml.Property) {
  		//stdout.println("Navigable property on association " + self.name + " - called " + p.name + " of type " + p.type.name )
  		//must get the navigator classifier.
  		self.memberEnd->forEach(prop : uml.Property) {
  			if (!prop.name.equals(p.name)){
  				//must get the global hashtable entry before updating it
  				var naviHash:Hashtable = propertyHashtable.get(prop.type.name)
  				naviHash.put(prop.type.name, p) //key= propertytype.name. Element=Property
  				propertyHashtable.put(prop.type.name, naviHash) //key propertytype.name (the name of the class that can navigate)
  			} //if
  		}//foreach prop
   	} //foreach p
  }
   
  /*
   * This function will find properties for the associations defined in the model and store them in the propertyHashtable hashtable
   * Each association that is navigable will result in a propory at its corresponding member end.
   * The records are stored as <association.name, hashtable<association.name,association>>	
   */

 uml.Classifier::createPropertyListForAssociations() {
   
    //now get the properties for this classifier from the global hashtable
    Hashtable pHash = propertyHashtable.get(self.name)
    
    //for each association owned by the classifier, check for navigation and update local hashtable
    self.getAssociations()->forEach(ass : uml.Association ) {
      	//stdout.println("INFO: Found association:" + ass.name + " for " + self.name)
      	     	
      	//only add the assocations that are navigable for the classifier in question
        ass.navigableOwnedEnd->forEach(c : uml.Classifier) {
           	if (c.name.equals(ass.name)){
        		pHash.put(ass.name, ass)  //key=association.name. Element= association
        	}
        }
    }
 	
 	//update propertyHashtable
    if (!pHash.isEmpty()){
 		propertyHashtable.put(self.name,pHash)  //key=classifier.name. Element=hashtable
   }
 }
 
 uml.Class::genImports() {
    'import java.util.Hashtable;\n'
	'import java.util.ArrayList;\n'
	'import java.util.List;\n\n'
    
    // Import universAAL packages. 
    // Note that generator currently imports a fixed set of classes. This will be improved in the future 
 	//'import org.universAAL.middleware.owl.ManagedIndividual;\n'
    //'import org.universAAL.middleware.service.owl.Service;\n'    
    //'import org.universAAL.ontology.phThing.Device;\n\n' 
    var importList:Hashtable = self.getImportsForClass()
    importList.keys()->forEach(impString:String) {
    	'import 'impString';\n'
    }
    '\n\n'
  }



  uml.Class::getImportsForClass():Hashtable {
    var classesReferredTo:Hashtable
    
	self.generalization->forEach(gen:uml.Generalization) {
		if (!self.package.name.equals(gen.general.package.name)) {
			var importName:String = gen.general.package.name + "." + gen.general.name
			classesReferredTo.put(importName,gen.general)
		}
	}
	if (classesReferredTo.isEmpty())
	  classesReferredTo.put("universAAL.middleware.owl.ManagedIndividual", null)
	  
	// Next, find properties  
	var props:Hashtable = propertyHashtable.get(self.name)  
	props->forEach(prop : uml.Property) {
	  if (prop.isDataType()) {
	    // TODO: Handle datatypes
	  }
	  else {
		if (!self.package.name.equals(prop.class.package.name)) {
			var importName:String = prop.class.package.name + "." + prop.class.name
			classesReferredTo.put(importName,prop)
		}
	  }
	}
	return classesReferredTo  
  } 



  uml.Class::genPropertyDeclaration() {
    '  public static final String MY_URI = ' ontologyNamespaceReference '\n'
    '    + "' self.name.trim() '";\n' 
    
    //get the property's hashtable and intialize the properties
    Hashtable props = propertyHashtable.get(self.name)
    
    //properties first
    props->forEach(att: uml.Property) {
  	    '  public static final String PROP_' att.toUpperFormat() ' = ' ontologyNamespaceReference '\n'
  	    '    + "' att.name.trim() '";\n'
	}

	//association properties next. The filter may be obsolete as the po
	props->forEach (ass : uml.Association) // | ass.endType.first().name.trim().equals(self.name.trim()) ) 
	{
	  //stdout.println("INFO: Generating static for associations: " + ass.name)
	  '  public static final String PROP_' ass.toUpperFormat() ' = ' ontologyNamespaceReference '\n'
	  '    + "' ass.name.trim() '";\n'
	  
	}
  	'\n'
  }     

  
  uml.Class::genConstructors() {
    '
  public ' self.name ' () {
    super();
  }
  
  public ' self.name ' (String uri) {
    super(uri);
  }\n'
  }    
  
  uml.Class::genGetClassURI() {
    '
  public String getClassURI() {
    return MY_URI;
  }\n'
  }    
  
 
  

  
  /**
   * TODO: Revise to correct scheme for subclassing with the new ontology encoding. 
   *
   * Generate the class declaration.   
   */
  uml.Class::genClassDeclaration() {
    var superClassName: String = "ManagedIndividual"
    
    'public ' if (self.isAbstract) {'abstract '} 'class ' self.name
    if (self.superClass.isEmpty()) {
      stdout.println("Warning: Class " + self.name + " has no super class. Script will default to" + superClassName )
      ' extends ' superClassName
    }
    else {  
      ' extends '
      self.superClass.first().name 
      if (self.superClass.size() > 1) {
        stdout.println("WARNING: Class " + self.name + " is defined to have multiple superclasses. Use interfaces instead - additional superclasses are igonered!")
      }        
    }
    if (!self.interfaceRealization.isEmpty()) {
      ' implements '
      var firstInter:Boolean 
      firstInter = true
      self.interfaceRealization->forEach(inter:uml.InterfaceRealization) {
        '' inter.supplier.first().name ' '
        if (!firstInter) {','}          
        firstInter = false
      }
    }
  }
  
  uml.Class::getURIExpressionForType(typeName : String):String {
    if (typeName == null) {
      typeName = "String"
    }
    if ((typeName == "Boolean") || (typeName == "Integer") || (typeName == "String")) {
      return "TypeMapper.getDatatypeURI(" + typeName + ".class)"
    }
    else if (typeName == "UnlimitedNatural") {
      return "TypeMapper.getDatatypeURI(Long.class)"    
    }
    return typeName+".MY_URI"    
  }

  
  uml.Class::genPropertiesForAssociations() {
      //generate 
      self.getAssociations()->forEach(ass : uml.Association | ass.endType.first().name.trim().equals(self.name.trim())) {
      '  public static final String PROP_'  ass.memberEnd.last().toUpperFormat() ';\n'
      }
		
  }


   uml.Class::genGetPropSerializationType() {
'  public int getPropSerializationType(String arg0) {
	// TODO Implement or if for Device subclasses: remove 
	return 0;
  }
'	    
   }

   uml.Class::genIsWellFormed() {
'
  public boolean isWellFormed() {
	return true '
	
	//get the hashtable
	Hashtable props = propertyHashtable.get(self.name)
	
	//attributes first
	props->forEach(att : uml.Property) {
  	    '\n      && hasProperty(PROP_'att.toUpperFormat()')'
  	}
  	
  	//associations next
 	props->forEach (ass : uml.Association) // | ass.endType.first().name.trim().equals(self.name.trim()) ) 
 	{
  	    '\n      && hasProperty(PROP_'ass.memberEnd.last().toUpperFormat()') '
 	}  
    ';
  }\n'
       
   }  
    

	/**
     * For each direct child under Service, the getClassLevelRestrictions operation should be generated
     */
	uml.Class::genGetClassLevelRestrictions() {
	  var isService:boolean = false
	  //check if one of the generalization (multiple inheritance supported on a model-level) is a Service
	  self.general->forEach(c : uml.Class){
	    //this is a rather vulnerable check. 
	    //TODO:Should include full namespace check
	    if (c.name.equals("Service")) {
	    	isService = true
	    }
	  
	  if (isService) {
'
  protected Hashtable getClassLevelRestrictions() {
	  return restrictions;
  }
'	
	  }
	}
  }


/**
 * Methods for generating getters and setters for properties.
 * NOTE: CAN BE SIMPLIFIED USING HASHTABLE
 */
   uml.Class::genPropertyGettersAndSetters() {
    //TODO: SIMPLIFY
   	//iterate through each property and generate getter and setter methods 
  	self.ownedMember->forEach(att : uml.Property) {
		var theTypeName:String = "String"	
		var methodName:String = att.name.trim().firstToUpper()
		var propLongName:String = "PROP_" + att.toUpperFormat()
		
		if (att.type != null) {
		  theTypeName = att.type.name
		}

		if ((att.upper > 1) or (att.upper == -1)) {
		  var includeAddMethod:Boolean = att.lower < 2
		  self.genArrayGetterAndSetter(methodName, propLongName, theTypeName, includeAddMethod)
		}
		else if (theTypeName == "Boolean") {
		  self.genBooleanGetterAndSetter(methodName, propLongName)
    	}  		  
		else if (theTypeName == "UnlimitedNatural") {
		  self.genLongGetterAndSetter(methodName, propLongName)
		}
   	    else if (theTypeName == "Integer") {
		  self.genIntGetterAndSetter(methodName, propLongName)
		}		
		else {
		  self.genObjectGetterAndSetter(methodName, propLongName, theTypeName)
		}	
	}
   }


   uml.Class::genArrayGetterAndSetter(methodName:String, propertyLongName:String, typeName:String, includeAdd:boolean) {
'
  public 'typeName'[] get'methodName'() {
    Object propList = getProperty('propertyLongName');
    if (propList instanceof List)
      return ('typeName'[]) ((List) propList).toArray(new 'typeName'[0]);
    else if (propList != null)
      return new 'typeName'[] {('typeName')propList}; // Handle special case of a single item not contained in a list
    return new 'typeName'[0];
  }
'
  if (includeAdd) {
'
  public void add'methodName'('typeName' newValue) {
    Object propList = getProperty('propertyLongName');
    List newList;
    if (propList instanceof List)
      newList = (List)propList;
    else {
      newList = new ArrayList();
      if (propList != null)
        newList.add(propList); // Handle special case of a single previous item not contained in a list
    }
    newList.add(newValue);
    setProperty('propertyLongName', newList);
  }
'
  } else {
'
  // No add'methodName'() method was generated because the lower cardinality of this
  // property is >= 2, and the generic add method implementation do not support this constraint
'    
  }
'  

  public void set'methodName'('typeName'[] propertyValue) {
    List propList = new ArrayList(propertyValue.length);
    for (int i = 0; i < propertyValue.length; i++) {
      propList.add(propertyValue[i]);
    }
    setProperty('propertyLongName', propList);
  }
'		
 
   }



/**
 *
 */
   uml.Class::genBooleanGetterAndSetter(methodName:String, propertyLongName:String) {
'
  public boolean is' methodName '() {
	Boolean b = (Boolean) getProperty('propertyLongName');
	return (b == null) ? false : b.booleanValue();
  }		

  public void set'methodName'(boolean newPropValue) {
      setProperty('propertyLongName', new Boolean(newPropValue));
  }		
'		
   }

/**
 *
 */   
   uml.Class::genIntGetterAndSetter(methodName:String, propertyLongName:String) {
'
  public int get' methodName '() {
	Integer i = (Integer) getProperty('propertyLongName');
	return (i == null) ? 0 : i.intValue();
  }		

  public void set'methodName'(int newPropValue) {
      setProperty('propertyLongName', new Integer(newPropValue));
  }		
'		
   }

/**
 *
 */
   uml.Class::genLongGetterAndSetter(methodName:String, propertyLongName:String) {
'
  public long get' methodName '() {
	Long l = (Long) getProperty('propertyLongName');
	return (l == null) ? 0 : l.longValue();
  }		

  public void set'methodName'(long newPropValue) {
      setProperty('propertyLongName', new Long(newPropValue));
  }		
'		
   }

/**
 *
 */
   uml.Class::genObjectGetterAndSetter(methodName:String, propertyLongName:String, typeName:String) {
'
  public 'typeName ' get' methodName '() {
    return ('typeName')getProperty('propertyLongName');
  }		

  public void set'methodName'('typeName' newPropValue) {
    if (newPropValue != null)
      setProperty('propertyLongName', newPropValue);
  }		
'		
   }
   
 uml.Package::generatePOMFile() {
     file("pom.xml" )
     //file( self.name.replace("\\.", "/") + '/' + "pom.xml" )
     
     //set the projectInfo hashtable
     projectInfo.put("name", self.owner.name.trim())
     projectInfo.put("artefactId", self.owner.name.trim())
     projectInfo.put("groupId", self.name.trim())
     projectInfo.put("versionInfo",  self.owner.getValue("owlOntology", "versionInfo").trim())
     
     self.genPOMFileHeader()
   }
 
 /**
  * This rule will populate the import model hashtable based on the external models imported in the model structure
  * It iterates over the packageimport elements and extracts the model-name (artefactID) and the model's owlOntology defaultnamespace and version
  */  
 uml.Model::getImportList() {
   //get the imported packages
  self.packageImport->forEach(c : uml.PackageImport) {
   	stdout.println("Found imported elements: " + c.importedPackage.name + " - " + c.importedPackage.getAppliedStereotypes())
   	if (c.importedPackage.hasStereotype("owlOntology")) {
   		stdout.println("Found owlOntology import. Adding import to list")
   		
   		//get the import name, default namespace and version to local hashtable
   		var modelImport:Hashtable
   		modelImport.put("name", c.importedPackage.name)
   		modelImport.put("defaultNamespace", c.importedPackage.getValue("owlOntology", "defaultNamespace"))
   		modelImport.put("versionInfo", c.importedPackage.getValue("owlOntology", "versionInfo"))
   		
   		//add hashtable to global list
   		importedModels.put(c.importedPackage.name, modelImport)
   		}
   	   
   	}
 	
 }

/**
 * Prints the POM file header, adding the project groupid, artefactid, version, name and description.
 */
 uml.Package::genPOMFileHeader() {
'<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion> 
  	<groupId>' projectInfo.get("groupId") '</groupId>
  	<artifactId>' projectInfo.get("artefactId") '</artifactId>
  	<version>' projectInfo.get("versionInfo") '</version>
  	<name>' projectInfo.get("name") '</name>
 	<description>' 
 	if (self.owner.ownedComment.first() != null) { 	  
 		''self.owner.ownedComment.first().body''
 	}
 	else {
 	  'No further description provided'
 	}
 	'</description>
 	<properties>
 	    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 	</properties>
  	<packaging>bundle</packaging>
    	<dependencies>'
    	//output dependencies for imported models
    
/*    	importedModels->forEach(i) {
    	  stdout.println("object has type: " + i)
 '	
 			<dependency>
    			<groupId>'i.get("name")'</groupId>
    			<artifactId>'i.get("defaultNamespace")'</artifactId>
    			<version>'i.get("versionInfo")'</version>
    		</dependency>'    	
    	} Need to find out how to set the right version numbers in models, and what to do with the -SNAPSHOT extension - for now use hardcoded*/ 			
'			
			<dependency>
				<groupId>org.apache.felix</groupId>
				<artifactId>org.osgi.core</artifactId>
				<version>1.0.1</version>
			</dependency>
'//			<!--
'			<dependency>
				<groupId>org.universAAL.middleware</groupId>
				<artifactId>mw.data.representation</artifactId>
				<version>1.0.1-SNAPSHOT</version>
			</dependency>
			<dependency>
				<groupId>org.universAAL.middleware</groupId>
				<artifactId>mw.bus.context</artifactId>
				<version>1.0.1-SNAPSHOT</version>
			</dependency>
			<dependency>
				<groupId>org.universAAL.middleware</groupId>
				<artifactId>mw.bus.io</artifactId>
				<version>1.0.1-SNAPSHOT</version>
			</dependency>
			<dependency>
				<groupId>org.universAAL.middleware</groupId>
				<artifactId>mw.bus.service</artifactId>
				<version>1.0.1-SNAPSHOT</version>
			</dependency>
			<dependency>
           		<groupId>org.universAAL.ontology</groupId>
           		<artifactId>ont.phWorld</artifactId>
				<version>1.0.1-SNAPSHOT</version>
       		</dependency>						
'//			-->
'		</dependencies>
  	  <build>
			<plugins>
				<plugin>
					<groupId>org.apache.felix</groupId>
					<artifactId>maven-bundle-plugin</artifactId>
					<extensions>true</extensions>
					<configuration>
						<instructions>
							<Bundle-Name>${project.name}</Bundle-Name>
							<Bundle-Activator>'self.name.trim()'.Activator</Bundle-Activator>
							<Bundle-Description>${project.description}</Bundle-Description>
							<Bundle-SymbolicName>${project.artifactId}</Bundle-SymbolicName>
							<Export-Package>'self.name.trim()'.owl.*</Export-Package>
							<Private-Package>'self.name.trim()'.*</Private-Package>							
						</instructions>
					</configuration>
				</plugin>
			</plugins>
		</build>
		<repositories>
			<repository>
				<id>central</id>
				<name>Central Maven Repository</name>
				<url>http://repo1.maven.org/maven2</url>
				<snapshots>
					<enabled>false</enabled>
				</snapshots>
			</repository>
			<repository>
				<id>apache-snapshots</id>
				<name>Apache Snapshots</name>
				<url>http://people.apache.org/repo/m2-snapshot-repository</url>
				<releases>
					<enabled>false</enabled>
				</releases>
				<snapshots>
					<updatePolicy>daily</updatePolicy>
				</snapshots>
			</repository>
			<repository>
				<id>uaal</id>
				<name>universAAL Repositories</name>
				<url>http://depot.universaal.org/maven-repo/releases/</url>
				<snapshots>
					<enabled>false</enabled>
				</snapshots>
			</repository>
			<repository>
				<id>uaal-snapshots</id>
				<name>universAAL Snapshot Repositories</name>
				<url>http://depot.universaal.org/maven-repo/snapshots/</url>
				<releases>
					<enabled>false</enabled>
				</releases>
			</repository>
		</repositories>
</project>
'
}

/**
 *
 */   
  uml.Classifier::printHashtable() {
  //this will just print the complete hashtable to console
  stdout.println("PropertyHashtable has " + propertyHashtable.size() + " elements")
  stdout.println("Keys: " + propertyHashtable.keys())
  propertyHashtable.keys()->forEach(c) {
  	stdout.println("Classifier:" + propertyHashtable.get(c))
  	}
  }
   	
 }

}

