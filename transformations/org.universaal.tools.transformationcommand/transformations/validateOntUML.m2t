texttransformation validateOntologyUml (in uml:"http://www.eclipse.org/uml2/3.0.0/UML") {
	
	var EntityList:list
	var PropertyList:list
	var ClassHashtable:hashtable
	var datatypeImportMap:hashtable
	var errorsList:list
	
	var debugEnabled:boolean = false
	var logEnabled:boolean = true
	
	var generalEntityTree:hashtable
	var listOfUpperOntologyEntities:hashtable
	
	uml.Model::main() {
	    // Init
	   	verbose("Initializing...", false, true)
		if (self.hasStereotype("owlOntology")) {
		    verbose("The owlOntology stereotype should NOW be applied to the root package(s).\nRemember to set all required values (defaultnamespace and name) for each package!",true,true)
		}
	   	
	   	// Create the list of upper ontology entities
	    self.createSuperentitiesList()
	    self.initDatatypeImportMap()
	    
	    if(listOfUpperOntologyEntities.size() == 0){
	    	verbose("No upper ontology defined!!",true,false)
	    } else {
	        self.ownedMember -> forEach( p:uml.Package ) {
				verbose("Start Processing Model Packages...", false, true)
				if (!p.hasStereotype("owlOntology")) {
					verbose("The package " + p.name + " is not stereotyped with owlOntology!\nIt is required to set the owlOntology stereotype on ALL root packages.",true,true)
				} else {
		    		p.processOntologyPackage()
				}
		 	}
	 	}
	    
	    if(!errorsList.isEmpty()) { 
			verbose("*** ERRORS OCCURRED WHILE CHECKING ***",false,true)
			if(!debugEnabled){
				errorsList->forEach(e){
					verbose(e,false,true);
				}
			}
		} else {
			verbose("\n\n--- EVERYTHING'S OK ---",false,false)
		}
	}

	uml.Package::processOntologyPackage() {
	  	// Creates the Model Entity List 
	  	verbose("Building Model Class list and tree",false,true) 
		self.ownedElement->forEach(c : uml.Class) {
			EntityList.add(c)
		  	c.updategeneralEntityTreeHashtable()
		}
   		
   		verbose("Start checking...",false,true) 
		// Check for empty Entity names or duplicate entry
    	if(self.checkEmpty(EntityList) && self.checkUnity(EntityList)){
      
      		
      		// If everything's ok continue..
			EntityList->forEach(entity : uml.Class) {
				entity.name = entity.name.trim()
				
    			verbose("Start "+entity.name+" analisys...",false,false)
    			
    			// 1. Class generalization Check
				verbose("Checking for right generalization of "+entity.name,false,false)
				entity.checkRightgeneralEntityTreeization(entity.name)
				
				// 2. Creates the Property List for each class
				// checking for no empty props or undefined props types
				PropertyList = entity.getPropertyList()
				
				// 2.1 look for dupicate entry for props
    			if(self.checkUnity(PropertyList) /*&& errorsList.isEmpty()*/){
    				//entity.updateHashtableClass(PropertyList)
    				
    				verbose("Checking for right Naming conventions for "+entity.name,false,false)
					// 3. Check naming conventions for classes and properties
    				entity.checkNamingConventions()
    				PropertyList->forEach(p:uml.Property){
    					p.checkNamingConventions()
    				}
				} 
			}
    	}
	}
	
	uml.Element::checkNamingConventions(){
		var elementProps:hashtable = self.getElementProps()
		var name:string = elementProps.get('name')
	  	var type:string = elementProps.get('type')
		var parent:string = elementProps.get('parent')
		
		if(self.allowedCharlist()){
			
			if(type=='Class'){
				if(!name.isUpperCase(0)){
					verbose (parent+name+": First character should be Uppercase",true,false)
				}
			} else {
				if(name.isUpperCase(0)){
					verbose (parent+name+": First character should be lowercase",true,false)
				}
			}
		} else verbose (parent+name+": No valid characters in name",true,false);
	}
	
	uml.Class::updategeneralEntityTreeHashtable() {
	  	if(self.general.size() > 0){
	  		if(self.general.size() > 1) verbose(self.name + ": Multiple superclasses found. Use interfaces instead - additional superclasses are igonered!",true,false)
			generalEntityTree.put(self.name, self.general.first()) // key: derived class name, value: parent class
		}
	}
		
	uml.Class::checkRightgeneralEntityTreeization(name:string) {
	  	var parent:uml.Class = generalEntityTree.get(self.name)
		if(parent != null){
			verbose(self.name+"->"+parent.name,false,false)
			if(parent.name.equals(name)){
				verbose(name+": circular derivation found!",true,false)
				return
			}
			if(self.checkIfFinal()) verbose(self.name+": Cannot have parent class!!",true,false)
			else parent.checkRightgeneralEntityTreeization(name)
		} else {
			if (self.checkIfFinal()) verbose("OK!!",false,false)
			else {
				var superEntities:string
				listOfUpperOntologyEntities->forEach(e:uml.Class) {
					superEntities = superEntities + e.name +"; "
				}
				verbose(name+": Must derive directly or indirectly from one of the entities of the upper ontology: "+superEntities,true,false)
    		}
		}
	}
	
	uml.Class::checkIfFinal():boolean {
		return (listOfUpperOntologyEntities.get(self.name) != null)
	}
	
	uml.Class::getPropertyList():list {
		var pList:list

		verbose("Getting properties of entity "+self.name,false,false)

		self.ownedMember->forEach(att : uml.Property) {
			
			att.name = att.name.trim()
			
			verbose('\tAdding property '+att.name+' (type:'+att.type.name+', size:'+att.name.size()+')',false,false)
			pList.add(att)
			
		 	if(att.name.size() == 0) verbose(self.name+": Empty "+att.oclGetType()+" name found",true,false)
		 	
		 	if(att.type == null) verbose(self.name+": Property "+att.name+" has UNDEFINED type",true,false)
			else if(!att.isDataType()) verbose(self.name+": Property "+att.name+" has UNKNOWN type",true,false)
		}

		if(pList.isEmpty()){
		  	verbose(self.name + ": NO properties found",true,false)
		}

		return pList
	}
	
	uml.Package::checkEmpty (someList:list):boolean {
		someList->forEach(e:uml.Classifier) {
			verbose("INFO: Element name:"+e.name+", element type:"+e.oclGetType(), false, false)
			if(e.name.size() == 0) {
				var parent:string
				if(e.oclGetType() == 'Class') parent = e.name
				else parent = e.owner.name
				verbose(parent+": Empty "+e.oclGetType()+" name not allowed",true,false)
        		return false
			}
		}
		return true
	}
	
	uml.Package::checkUnity (someList:list):boolean {
		var toBeChecked:string
		var repetitions:integer
		var repeatedElements:hashtable
		var parent:string
		var res:boolean = true
		
		someList->forEach(e) {
			var elementProps:hashtable = e.getElementProps()
			parent = elementProps.get('parent')
			toBeChecked = elementProps.get('name');
			repetitions = repeatedElements.get(elementProps.get('name')+":"+elementProps.get('type'))
			if (repetitions == null) repetitions = 1
			else repetitions = repetitions + 1
			repeatedElements.put(elementProps.get('name')+":"+elementProps.get('type'), repetitions)
		}
	  
		if(!repeatedElements.isEmpty()) {
	
			var repeatedEntitiesNames:list = repeatedElements.keys()
		     
			repeatedEntitiesNames->forEach(e){
				var times:integer = repeatedElements.get(e)
				var eName:string  = e.substring(0, e.lastIndexOf(":"))
				var eType:string  = e.substring(e.lastIndexOf(":")+1, e.size())
		    	
		    	if(times >1){
		    		verbose(parent+"Duplicate entry for "+eType+" "+eName+" ("+times+" duplicates)",true,false)
		    		res = false
		    	}
			}
		}
		return res
 
	}
	
	uml.Class::getElementProps():hashtable {
		var pHash:hashtable
		pHash.put('name',self.name);
		pHash.put('type',self.oclGetType());
		pHash.put('parent','');
		return pHash
	}
	
	uml.Property::getElementProps():hashtable {
		var pHash:hashtable
		pHash.put('name',self.name);
		pHash.put('type',self.oclGetType());
		pHash.put('parent',self.class.name+': ');
		return pHash
	}
	
	uml.Class::updateHashtableClass(pList:list) {
		if (!pList.isEmpty()){
			var pHash:hashtable
			pList->forEach(e:uml.Property){
				pHash.put(e.name,e)
			}
			ClassHashtable.put(self.name,pHash) //key=class.name. pHash = hashtable of properties
			verbose("Entity Hashtable updated for key " + self.name + " (properties=" + pHash.size() +"). Hashtable size=" + ClassHashtable.size() ,false,false)
		} 
	}
  
	// OLD: Create list of generic class that MUST BE DERIVED from all the other classes
	/*uml.Model::createSuperentitiesList() {
		listOfUpperOntologyEntities.add("Service")
		listOfUpperOntologyEntities.add("Device")
		listOfUpperOntologyEntities.add("ManagedIndividual")
	}*/
	
	// Create list of generic class that MUST BE DERIVED from all the other classes
	uml.Model::createSuperentitiesList(){
		self.packageImport->forEach(p:uml.PackageImport){
			p.relatedElement->forEach(m:uml.Model | m.name.startsWith("org.universaal.")){
				m.ownedMember->forEach(package:uml.Package){
					package.ownedMember->forEach(class:uml.Class){
						listOfUpperOntologyEntities.put(class.name,class)
					}
				}
			}
		}
	}

	/**
	 * Crate a map containing the basic datatypes supported.
	 */		
	uml.Model::initDatatypeImportMap() {
		datatypeImportMap.put("Boolean", " ")
	    datatypeImportMap.put("Integer", " ")
	    datatypeImportMap.put("Float", " ")
	    datatypeImportMap.put("UnlimitedNatural", " ")
	    datatypeImportMap.put("Long", " ")
	    datatypeImportMap.put("String", " ")
	    datatypeImportMap.put("Float", " ")
	    datatypeImportMap.put("Double", " ")
	    datatypeImportMap.put("XMLGregorianCalendar", "javax.xml.datatype.XMLGregorianCalendar")
	    datatypeImportMap.put("Duration", "javax.xml.datatype.Duration")
	    datatypeImportMap.put("Locale", "java.util.Locale")
	}		
		
		
	/**
	 * Check if a property is one of the defined basic data types
	 */		
	uml.Property::isDataType() {
		var theTypeName:String = self.type.name
		var isDatatype:boolean = (datatypeImportMap.get(theTypeName) != null)
		return isDatatype
	}
	
	// Common check for Class and Property
	uml.Element::allowedCharlist():boolean{
		var elementProps:hashtable = self.getElementProps()
		var what:string = elementProps.get('name')
	  	var type:string = elementProps.get('type')
		var parent:string = elementProps.get('parent')
		// no whitespaces
		if(what.contains(" ")) verbose(parent+what+": Spaces not allowed in name's "+type,true,false)
		
		// no numbers at the beginning
		if(what.startsWith("0") ||
		   what.startsWith("1") ||
		   what.startsWith("2") ||
		   what.startsWith("3") ||
		   what.startsWith("4") ||
		   what.startsWith("5") ||
		   what.startsWith("6") ||
		   what.startsWith("7") ||
		   what.startsWith("8") ||
		   what.startsWith("9")) verbose(parent+what+": First "+type+" character's name cannot be a number",true,false)
		
		// only alphanumeric chars plus the undescore allowed
		what = what.replace("[A-za-z0-9_ ]","")
		return (what.size()==0)
	}
	
	verbose(message:string, error:boolean, force:boolean) {
		if(error){
		  	message = "*** ERROR *** : " + message
		 	errorsList.add(message)
		} 
		if(debugEnabled || force) stdout.println(message)
		
		if(logEnabled) log(message)
	}
		
}