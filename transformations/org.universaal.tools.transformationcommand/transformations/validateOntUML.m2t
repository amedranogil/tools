texttransformation validateOntologyUml (in uml:"http://www.eclipse.org/uml2/3.0.0/UML") {
	
	var EntityList:list
	var PropertyList:list
	var ClassHashtable:hashtable
	var datatypeImportMap:hashtable
	var errorsList:list
	var errors:integer = 0
	var warnings:integer = 0
	
	var debugEnabled:boolean = false
	var logEnabled:boolean = true
	
	var generalEntityTree:hashtable
	var listOfUpperOntology:hashtable
	
	uml.Model::main() {
	    // Init
	   	verbose("----\nStart validation of UML ontology model "+self.name+"\n----\n",false,true)
	   	verbose("Initializing\n", false, true)
		if (self.hasStereotype("owlOntology")) {
		    verbose("* The owlOntology stereotype should NOW be applied to the root package(s).\nRemember to set all required values (defaultnamespace and name) for each package!\n",true,true)
		}
	   	
	   	// Create the list of upper ontology entities
	    self.createSuperentitiesList()
	    self.initDatatypeImportMap()
	    
	    if(listOfUpperOntology.size() == 0){
	    	verbose("* No upper ontology defined!!\n",true,false)
	    } else {
	        self.ownedMember -> forEach( p:uml.Package ) {
				verbose("Start Processing Model Packages\n", false, true)
				if (!p.hasStereotype("owlOntology")) {
					verbose("* The package " + p.name + " is not stereotyped with owlOntology!\nIt is required to set the owlOntology stereotype on ALL root packages.\n",true,true)
				}
				p.processOntologyPackage()
		 	}
	 	}
	    
	    verbose("----\nCheck Report:\n",false,true)
	    
	    if(!errorsList.isEmpty()) { 
			verbose(errorsList.size()+" problem(s) occurred when validating UML ontology model #"+self.name+"\n----\n",false,true)
			if(!debugEnabled){
				errorsList->forEach(e){
					verbose(e,false,true);
				}
			}
		} else {
			verbose("EVERYTHING'S OK!\n----\n",false,false)
		}
	}

	uml.Package::checkErrors(){
	  	if(errors > 0 || warnings > 0){
			verbose("  "+errors+" error(s), "+warnings+" warning(s)!\n",false,true)
		} else {
			verbose("  OK!\n",false,true)
		}
		
		errors = 0
		warnings = 0
	}

	uml.Package::processOntologyPackage() {
	  	// Creates the Model Entity List 
	  	verbose("Building Model Class list and tree...",false,true) 
		self.ownedElement->forEach(c : uml.Class) {
			c.name = c.name.trim()
			EntityList.add(c)
		  	c.updateGeneralEntityTreeHashtable()
		}
   		
   		self.checkErrors()
		
   		verbose("Checking for unnamed entities or entities whith the same name... ",false,true) 
   		
		// Check for empty Entity names or duplicate entry
    	if(self.checkEmpty(EntityList) && self.checkUnity(EntityList)){
      		verbose("OK!!\n",false,true)
      			
      		// If everything's ok continue..
			EntityList->forEach(entity : uml.Class) {
				verbose("Class "+entity.name+"...",false,true)
    			
    			// 1. Class generalization Check
				verbose("\nChecking for right generalization of "+entity.name+"...\n",false,false)
				entity.checkRightGeneralization(entity.name)
				
				verbose("\nChecking for right naming conventions of "+entity.name+"...\n",false,false)
				entity.checkNamingConventions()
    			
    			// 2. Creates the Property List for each class
				// checking for no empty props or undefined props types
				PropertyList = entity.getPropertyList()
				self.checkEmpty(PropertyList)
				self.checkUnity(PropertyList)
				
				PropertyList->forEach(p:uml.Property){
					p.checkNamingConventions()
				}
				
				self.checkErrors()
			}
    	} else verbose("\nThe control can not continue because of fatal errors\n",false,true)

	}
	
	uml.Classifier::checkNamingConventions(){
		var elementProps:hashtable = self.getElementProps()
		var name:string = elementProps.get('name')
	  	var type:string = elementProps.get('type')
		var parent:string = elementProps.get('parent')
		
		if(self.allowedCharlist()){
			
			if(name.size()>0){
				if(type=='Class'){
					if(!name.isUpperCase(0)){
						verbose ("!"+parent+name+": First character's name should be Uppercase\n",true,false)
					}
				} else {
					if(name.isUpperCase(0)){
						verbose ("!"+parent+name+": First character's name should be lowercase\n",true,false)
					}
				}
			}
		} else verbose ("*"+parent+name+": No valid characters in name\n",true,false);
	}
	
	uml.Class::updateGeneralEntityTreeHashtable() {
	  	if(self.general.size() > 0){
	  		if(self.general.size() > 1) verbose("!"+self.name + ": Multiple superclasses found. Use interfaces instead - additional superclasses are igonered!\n",true,false)
			generalEntityTree.put(self.name, self.general.first()) // key: derived class name, value: parent class
		}
	}
		
	uml.Class::checkRightGeneralization(name:string) {
		var ontKeys:list = listOfUpperOntology.keys()
		ontKeys->forEach(ontName){
			var listOfUpperOntologyEntities:hashtable = listOfUpperOntology.get(ontName)
			if(listOfUpperOntologyEntities.get(name) != null){
				verbose("!"+self.name+": the same name has already been defined in the upper ontology #"+ontName,true,false)
				return
			}
		}
		var parent:uml.Class = generalEntityTree.get(self.name)
	  	if(parent != null){
			verbose(self.name+"->"+parent.name,false,false)
			if(parent.name.equals(name)){
				verbose("*"+name+": circular derivation found!\n",true,false)
				return
			}
			if(self.checkIfFinal()) verbose("*"+self.name+": Cannot have parent class!!\n",true,false)
			else parent.checkRightGeneralization(name)
		} else {
			if (self.checkIfFinal()) verbose("OK!!\n",false,false)
			else {
				verbose("*"+name+": Must derive directly or indirectly from one of the entities of the upper ontology\n",true,false)
    		}
		}
	}
	
	uml.Class::checkIfFinal():boolean {
		var ontKeys:list = listOfUpperOntology.keys()
		ontKeys->forEach(ontName){
			var listOfUpperOntologyEntities:hashtable = listOfUpperOntology.get(ontName)
			if(listOfUpperOntologyEntities.get(self.name) != null){
				return true
			}
		}
		return false
	}
	
	uml.Class::getPropertyList():list {
		var pList:list

		verbose("Getting properties of entity "+self.name,false,false)

		self.ownedMember->forEach(att : uml.Property) {
			
			att.name = att.name.trim()
			
			verbose('\tAdding property '+att.name+' (type:'+att.type.name+', size:'+att.name.size()+')',false,false)
			pList.add(att)
			
			if(att.name.size()>0){
				if(att.association == null) {
				 	if(att.type == null) verbose("!"+self.name+": Property "+att.name+" has UNDEFINED type\n",true,false)
					else if(!att.isDataType()) verbose("!"+self.name+": Property "+att.name+" has UNKNOWN type\n",true,false)
				}
			}
		}

		if(pList.isEmpty()){
		  	verbose("!"+self.name + ": NO properties found\n",true,false)
		}

		return pList
	}
	
	uml.Package::checkEmpty (someList:list):boolean {
		var ret:boolean = true
		var howmany:integer = 0
		var parent:string
		var type:string
		
		someList->forEach(e) {
		  	var elementProps:hashtable = e.getElementProps()
		  	if(parent == null) parent = elementProps.get('parent')
		  	if(type == null) type = elementProps.get('type')
			verbose("INFO: Element name:"+elementProps.get('name')+", element type:"+type+"\n", false, false)
			if(elementProps.get('name').size() == 0) {
        		howmany = howmany + 1
        		ret = false
			}
		}
		
		if(howmany > 0) verbose("*"+parent+"Found "+howmany+" unnamed "+type,true,false)
		
		return ret
		
	}
	
	uml.Package::checkUnity (someList:list):boolean {
		var repeatedElements:hashtable
		var res:boolean = true
		var parent:string 
		
		someList->forEach(e) {
		  	var elementProps:hashtable = e.getElementProps()
			var repetitions:integer = repeatedElements.get(elementProps.get('name').toLower()+":"+elementProps.get('type'))
			if(parent == null) parent = elementProps.get('parent')
			
			if (repetitions == null) repetitions = 1
			else repetitions = repetitions + 1
			repeatedElements.put(elementProps.get('name').toLower()+":"+elementProps.get('type'), repetitions)
			
		}
	  
		if(!repeatedElements.isEmpty()) {
	
			var repeatedEntitiesNames:list = repeatedElements.keys()
		     
			repeatedEntitiesNames->forEach(e){
				var times:integer = repeatedElements.get(e)
				var eName:string  = e.substring(0, e.lastIndexOf(":"))
				var eType:string  = e.substring(e.lastIndexOf(":")+1, e.size())
		    	
		    	if(times >1){
		    		verbose("*"+parent+"Multiple "+eType+" with same (case-independent) name ("+times+" duplicates of "+eName+")\n",true,false)
		    		res = false
		    	}
			}
		}
		return res
 
	}

	uml.Classifier::getElementProps(){
		var pHash:hashtable
		pHash.put('name',self.name);
		pHash.put('type',self.oclGetType());
		if(self.oclGetType().equals('Class')){
			pHash.put('parent','');
		} else {
			var prop:uml.Property
			prop = self
			pHash.put('parent',prop.class.name+': ');
		}
		return pHash
	}

	uml.Class::updateHashtableClass(pList:list) {
		if (!pList.isEmpty()){
			var pHash:hashtable
			pList->forEach(e:uml.Property){
				pHash.put(e.name,e)
			}
			ClassHashtable.put(self.name,pHash) //key=class.name. pHash = hashtable of properties
			verbose("Entity Hashtable updated for key " + self.name + " (properties=" + pHash.size() +"). Hashtable size=" + ClassHashtable.size() ,false,false)
		} 
	}
  
	// Create list of generic class that MUST BE DERIVED from all the other classes
	uml.Model::createSuperentitiesList(){
		self.packageImport->forEach(p:uml.PackageImport){
			p.relatedElement->forEach(m:uml.Model | m.name.startsWith("org.universaal.")){
			  	var listOfUpperOntologyEntities:hashtable
				m.ownedMember->forEach(package:uml.Package){
					package.ownedMember->forEach(class:uml.Class){
						listOfUpperOntologyEntities.put(class.name,class)
						datatypeImportMap.put(class.name,m.name)
					}
				}
				listOfUpperOntology.put(m.name,listOfUpperOntologyEntities)
			}
		}
	}

	/**
	 * Crate a map containing the basic datatypes supported.
	 */		
	uml.Model::initDatatypeImportMap() {
		datatypeImportMap.put("Boolean", " ")
	    datatypeImportMap.put("Integer", " ")
	    datatypeImportMap.put("Float", " ")
	    datatypeImportMap.put("UnlimitedNatural", " ")
	    datatypeImportMap.put("Long", " ")
	    datatypeImportMap.put("String", " ")
	    datatypeImportMap.put("Float", " ")
	    datatypeImportMap.put("Double", " ")
	    datatypeImportMap.put("XMLGregorianCalendar", "javax.xml.datatype.XMLGregorianCalendar")
	    datatypeImportMap.put("Duration", "javax.xml.datatype.Duration")
	    datatypeImportMap.put("Locale", "java.util.Locale")
	}		
		
		
	/**
	 * Check if a property is one of the defined basic data types
	 */		
	uml.Property::isDataType() {
		var theTypeName:String = self.type.name
		var isDatatype:boolean = (datatypeImportMap.get(theTypeName) != null)
		return isDatatype
	}
	
	// Common check for Class and Property
	uml.Classifier::allowedCharlist():boolean{
		var elementProps:hashtable = self.getElementProps()
		
		var what:string = elementProps.get('name')
	  	var type:string = elementProps.get('type')
		var parent:string = elementProps.get('parent')
		
		// no numbers at the beginning
		if(what.startsWith("0") ||
		   what.startsWith("1") ||
		   what.startsWith("2") ||
		   what.startsWith("3") ||
		   what.startsWith("4") ||
		   what.startsWith("5") ||
		   what.startsWith("6") ||
		   what.startsWith("7") ||
		   what.startsWith("8") ||
		   what.startsWith("9")) verbose("*"+parent+what+": First "+type+" character's name cannot be a number\n",true,false)
		
		// only alphanumeric chars plus the undescore allowed
		what = what.replace("[A-za-z0-9_ ]","")
		return (what.size()==0)
	}
	
	verbose(message:string, error:boolean, force:boolean) {
		if(error){
		  	errorsList.add(message)
		  	if(message.startsWith("*")) errors = errors + 1
		  	else warnings = warnings + 1
		} 
		if(debugEnabled || force){
			if(message.endsWith("\n"))
				stdout.println(message.substring(0, message.size()-1))
			else
				stdout.print(message)
		}
		
		if(logEnabled) log(message)
	}
		
}