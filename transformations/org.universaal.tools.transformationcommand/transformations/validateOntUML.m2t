texttransformation validateOntologyUml (in uml:"http://www.eclipse.org/uml2/3.0.0/UML") {
	
	var EntityList:list
	var PropertyList:list
	var ClassHashtable:hashtable
	var dataWarningMap:hashtable
	var errorsList:list
	
	var debugEnabled:boolean = true
	var logEnabled:boolean = true
	
	var general:hashtable
	var listOfUpperOntologyEntities:list
	
	uml.Model::main() {
	    // Init
	   	verbose("Initializing...", false, true)
	
	   	// Create the list of upper ontology entities
	    self.createSuperentitiesList()
	    
	    if(listOfUpperOntologyEntities.size() == 0){
	    	verbose("No upper ontology defined!!",true,false)
	    } else {
	        self.ownedMember -> forEach( p:uml.Package ) {
				verbose("Start Processing Model Packages...", false, true)
				if (!p.hasStereotype("owlOntology")) {
					verbose("The package " + p.name + " is not stereotyped with owlOntology!\nIt is required to set the owlOntology stereotype on ALL root packages.",true,true)
				} else {
		    		p.processOntologyPackage()
				}
		 	}
	 	}
	    
	    if(!errorsList.isEmpty()) { 
			verbose("*** ERRORS OCCURRED WHILE CHECKING ***",false,true)
			if(!debugEnabled){
				errorsList->forEach(e){
					verbose(e,false,true);
				}
			}
		} else {
			verbose("\n\n--- EVERYTHING'S OK ---",false,false)
		}
	}

	uml.Package::processOntologyPackage() {
	  	// Creates the Model Entity List 
	  	verbose("Building Model Class list and tree",false,true) 
		self.ownedElement->forEach(c : uml.Class) {
		  	EntityList.add(c)
		  	c.updateGeneralHashtable()
		}
   		
   		verbose("Start checking...",false,true) 
		// Check for empty Entity names or duplicate entry
    	if(self.checkEmpty(EntityList) && self.checkUnity(EntityList)){
      
      		
      		// If everything's ok continue..
			EntityList->forEach(entity : uml.Class) {
    			verbose("Start "+entity.name+" analisys...",false,false)
    			
    			// 1. Class Generalization Check
				verbose("Checking for right generalization of "+entity.name,false,false)
				entity.checkRightGeneralization(entity.name)
				
				// 2. Creates the Property List for each class
				// and checks for no empty props, undefined props types and dupicate entry for props
				PropertyList = entity.getPropertyList()
    			if(self.checkUnity(PropertyList) && errorsList.isEmpty()){
					entity.updateHashtableClass(PropertyList)
				} 
						
			}
			
			
    	}
    
	}
	
	uml.Class::updateGeneralHashtable() {
	  	if(self.general.size() > 0){
	  		if(self.general.size() > 1) verbose(self.name + ": Multiple superclasses found. Use interfaces instead - additional superclasses are igonered!",true,false)
			general.put(self.name, self.general.first()) // key: derived class name, value: parent class
		}
	}
		
	uml.Class::checkRightGeneralization(name:string) {
	  	var parent:uml.Class = general.get(self.name)
		if(parent != null){
			verbose(self.name+"->"+parent.name,false,false)
			if(parent.name.equals(name)){
				verbose(name+": circular derivation found!",true,false)
				return
			}
			if(self.checkIfFinal()) verbose(self.name+": Cannot have parent class!!",true,false)
			else parent.checkRightGeneralization(name)
		} else {
			if (self.checkIfFinal()) verbose("OK!!",false,false)
			else {
				var superEntities:string
				listOfUpperOntologyEntities->forEach(e:uml.Class) {
					superEntities = superEntities + e.name +"; "
				}
				verbose(name+": Must derive directly or indirectly from one of the entities of the upper ontology: "+superEntities,true,false)
    		}
		}
	}
	
	uml.Class::checkIfFinal():boolean {
		listOfUpperOntologyEntities->forEach(e:uml.Class) {
			if(e.name.equals(self.name)) return true
		}
		return false
	}
	
	uml.Class::getPropertyList():list {
		var pList:list

		verbose("Getting properties of entity "+self.name,false,false)

		self.ownedMember->forEach(att : uml.Property) {
		 	verbose('\tAdding property '+att.name+' (type:'+att.type.name+', size:'+att.name.size()+')',false,false)
			
			att.name = att.name.trim()
			
			if(att.name.size() == 0) verbose(self.name+": Empty property found",true,false)
			if(att.type == null) verbose(self.name+": Property "+att.name+" has UNDEFINED type",true,false)
				
			pList.add(att)
		}

		if(pList.isEmpty()){
		  	verbose(self.name + ": NO properties found",true,false)
		}

		return pList
	}
	
	uml.Package::checkEmpty (someList:list):boolean {
		someList->forEach(e) {
			var elementProps:hashtable = e.getElementProps()
			verbose("INFO: Element name:"+elementProps.get('name')+", element type:"+elementProps.get('type'), false, false)
			if(elementProps.get('name').size() == 0) {
        		verbose(elementProps.get('parent')+"Empty "+elementProps.get('type')+" names not allowed\n----",true,false)
        		return false
			}
		}
		return true
	}
	
	uml.Package::checkUnity (someList:list):boolean {
	  
		var toBeChecked:string
		var repetitions:integer
		var repeatedElements:hashtable
		var parent:string
		
		someList->forEach(e) {
		  	var elementProps:hashtable = e.getElementProps()
			parent = elementProps.get('parent')
			toBeChecked = elementProps.get('name');
			repetitions = self.checkDuplicates(someList, toBeChecked)
			if(repetitions > 1) repeatedElements.put(elementProps.get('name')+":"+elementProps.get('type'), repetitions)
		}
	  
		if(!repeatedElements.isEmpty()) {
	
			var repeatedEntitiesNames:list = repeatedElements.keys()
		     
			repeatedEntitiesNames->forEach(e){
				var times:integer = repeatedElements.get(e)
				var eName:string  = e.substring(0, e.lastIndexOf(":"))
				var eType:string  = e.substring(e.lastIndexOf(":")+1, e.size())
		      
				verbose(parent+"Duplicated entry for "+eType+" "+eName+" ("+times+" duplicates)\n----",true,false)
			}
		
			return false
		  
		}
		return true
 
	}

	
	uml.Class::getElementProps():hashtable {
		var pHash:hashtable
		pHash.put('name',self.name);
		pHash.put('type',self.oclGetType());
		pHash.put('parent',false);
		return pHash
	}
	
	uml.Property::getElementProps():hashtable {
		var pHash:hashtable
		pHash.put('name',self.name);
		pHash.put('type',self.oclGetType());
		pHash.put('parent',self.class.name+": ");
		return pHash
	}
	
	uml.Class::updateHashtableClass(pList:list) {
		if (!pList.isEmpty()){
			var pHash:hashtable
			pList->forEach(e:uml.Property){
				pHash.put(e.name,e)
			}
			ClassHashtable.put(self.name,pHash) //key=class.name. pHash = hashtable of properties
			verbose("Entity Hashtable updated for key " + self.name + " (properties=" + pHash.size() +"). Hashtable size=" + ClassHashtable.size() ,false,false)
		} 
	}
  
	// OLD: Create list of general class that MUST BE DERIVED from all the other classes
	/*uml.Model::createSuperentitiesList() {
		listOfUpperOntologyEntities.add("Service")
		listOfUpperOntologyEntities.add("Device")
		listOfUpperOntologyEntities.add("ManagedIndividual")
	}*/
	
	// Create list of general class that MUST BE DERIVED from all the other classes
	uml.Model::createSuperentitiesList(){
		self.packageImport->forEach(p:uml.PackageImport){
			p.relatedElement->forEach(m:uml.Model | m.name.startsWith("org.universaal.")){
				m.ownedMember->forEach(package:uml.Package){
					package.ownedMember->forEach(class:uml.Class){
						listOfUpperOntologyEntities.add(class)
					}
				}
			}
		}
	}

	
	uml.Package::checkDuplicates(someList:list, what:string):integer {
		var times:integer = 0
		someList->forEach(e){
        var elementName:string = e.name.trim();
        if (elementName.equals(what)) times = times + 1;
	   }
	   return times
	}
	
	verbose(message:string, error:boolean, force:boolean) {
		if(error){
		  	message = "*** WARNING *** : " + message
		 	errorsList.add(message)
		} 
		if(debugEnabled || force) stdout.println(message)
		if(logEnabled) log(message)
	}
		
}